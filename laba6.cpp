#include <iostream>
#include <fstream>

using namespace std;

void chtenie(int mas[20][20], int &MatrixSize) // создал функцию, которая занимается чтением файла
{ // & это ссылка, если ссылки нет, то прога создает в памяти копию переменной и меняет ее, а исходная не меняется, если ссылка есть, то меняется исходная переменная
	ifstream in("input.txt", ios::in); // это база
	int s = 0;
	int k = 0;
	int l = 0;
	while (!in.eof())
	{
		if (s == 0) // здесь я считываю размер матрицы с файла, переменная s нужна для того, чтобы не читать размер и сразу начинать чтение с самой матрицы
		{// но можно сделать проще, тупо перед циклом написать int >> MatrixSize, а в цикле тупо считывать матрицу, по логике он должен размер будет сам пропустить
			in >> MatrixSize;
			s++;
		}
		else
		{
			in >> mas[k][l]; // это запись матрицы в двумерный массив для удобства работы
			l++; // смена столбцов
		}
		if (l == MatrixSize) 
		{
			k++; // если дошел до края матрицы то меняем строку на следующую
			l = 0; // обнуление столбца, чтобы он записывал элемент не в какой-нибудь 10 столбец а в первый
		}
	}
	in.close(); // надо закрыть файл
}

void Replace(int mas[20][20], int MatrixSize) // функция которая изменяет значения
{
	int a, tmp, proizv = Multiplication(mas, MatrixSize); // сначала вызывается функция произведения(см ниже)
	for (int i = 0; i < MatrixSize; i++)
	{
		for (int j = 0; j < MatrixSize; j++)
		{
			tmp = mas[i][j]; // сохраняю элемент в буфер
			while (tmp != 0)
			{
				a = tmp % 10; // берём последнюю цифру
				tmp /= 10; // отсекаем
				if (a == 0) // если есть 0, то заменяем элемент на произведение
				{
					mas[i][j] = proizv;
				}
			}
		}
	}
}

int Multiplication(int mas[20][20], int MatrixSize) //это та самая функция произведения, в ней возвращается переменная, в которой находится произведение диагональных элементов
{
	int proizv = 1;
	for (int i = 0; i < MatrixSize; i++) 
	{
		proizv *= mas[i][i]; // [i][i] это типа диагональный элемент, 1 1, 2 2 и т.д.
	}
	return proizv;// ретурн возвращает значение, типо в мейне можно создать переменную и приравнять её функции, причем функция можно сказать равна значению, которое в ней возвращается
}

bool MaxElement(int mas[20][20], int MatrixSize) // проверка на то, что все эл-ты диагонали являются максимальными числами своих строк
{
	int k = 1; // это датчик максимальности
	bool flag = false; // это типо тоже датчик максимальности
	for (int i = 0; i < MatrixSize; i++)
	{
		for (int j = 0; j < MatrixSize; j++)
		{
			if (mas[i][i] > mas[i][j]) // диаг-ый эл-т сравнивается с каждый в своей строке, если он больше, то умножаем к на 1
			{

				k *= 1;
			}
			if (mas[i][i] <= mas[i][j]) // иначе умножаем на 0, если хотя-бы один диаг-ый эл-т меньше одного эл-та своей строки, то всё, гг, ничего менять не надо
			{
				k *= 0; // взял именно инт, потому что бул будет постоянно меняться, а если к один раз стал нулем, то он всегда будет нулем его нельзя изменить умножением
			}
		}
	}
	if (k == 1) // если все эл-ты удовлетворяют условию, то возвращам тру типо всё круто
	{
		flag = true;
	}
	return flag;
}

void Zapis(int mas[20][20], int MatrixSize)// ну и вывод, тут ничо необычного нет, самый базовый код
{
	ofstream out("output.txt", ios::out);
	for (int i = 0; i < MatrixSize; i++)
	{
		for (int j = 0; j < MatrixSize; j++)
		{
			out << mas[i][j] << " ";
		}
		out << endl;
	}
	out.close();
}

void asd(int x) // это те приколы со ссылкой которые он говорил делать
{
	x ++;
	cout << x << endl;
}

void asdf(int &x) // типо тот без ссылки,  а этот с, и надо показать типо ты шаришь как они изменяются, вместо х можешь другую переменную написать, ну и другое название функции написать
{
	x ++;
	cout << x << endl;
}

int main()
{
	setlocale(LC_ALL, "Ru");
	int mas[20][20], MatrixSize;
	chtenie(mas, MatrixSize); // функция чтения
	if (MaxElement(mas, MatrixSize)) // если удовлетворяется условие
	{
		Replace(mas, MatrixSize); // то заменяем все эл-ты содержащие 0
	}
	Zapis(mas, MatrixSize); // вывод в файл

	int x = 5; // а это приколы с теми ссылками
	cout << x << endl;
	asd(x);
	asdf(x);
}